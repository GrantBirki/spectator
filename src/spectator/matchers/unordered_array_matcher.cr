require "./value_matcher"

module Spectator::Matchers
  # Matcher for checking that the contents of one array (or similar type)
  # has the exact same contents as another, but in any order.
  struct UnorderedArrayMatcher(ExpectedType) < ValueMatcher(Enumerable(ExpectedType))
    # Determines whether the matcher is satisfied with the partial given to it.
    def match(partial, negated = false)
      expected_elements = expected.to_a
      actual = partial.actual.to_a
      missing, extra = array_diff(expected, actual)

      values = ExpectedActual.new(expected_elements, label, actual, partial.label)
      if missing.empty? && extra.empty?
        IdenticalMatchData.new(values)
      else
        ContentMatchData.new(values, missing, extra)
      end
    end

    # Finds the difference of two unordered arrays.
    # Returns a tuple of arrays - missing from *actual* and extra in *actual*.
    private def array_diff(expected, actual)
      extra = actual.dup
      missing = [] of ExpectedType

      # TODO: OPTIMIZE
      expected.each do |item|
        index = extra.index(item)
        if index
          extra.delete_at(index)
        else
          missing << item
        end
      end

      {missing, extra}
    end

    # Creates the value matcher.
    # The label should be a string representation of the expectation.
    # The expected value is stored for later use.
    def initialize(expected : Enumerable(ExpectedType), label : String)
      super
    end

    # Creates the value matcher.
    # The label is generated by calling `#to_s` on the expected value.
    # The expected value is stored for later use.
    def initialize(expected : Enumerable(ExpectedType))
      super
    end

    # Common functionality for all match data for this matcher.
    private abstract struct CommonMatchData(ExpectedType, ActualType) < MatchData
      # Creates the match data.
      def initialize(matched, @values : ExpectedActual(Array(ExpectedType), Array(ActualType)))
        super(matched)
      end

      # Basic information about the match.
      def named_tuple
        {
          expected: NegatableMatchDataValue.new(@values.expected),
          actual:   @values.actual,
        }
      end

      # Describes the condition that satisfies the matcher.
      # This is informational and displayed to the end-user.
      def message
        "#{@values.actual_label} contains #{@values.expected_label} (unordered)"
      end
    end

    # Match data specific to this matcher.
    # This type is used when the actual value matches the expected value.
    private struct IdenticalMatchData(ExpectedType, ActualType) < CommonMatchData(ExpectedType, ActualType)
      # Creates the match data.
      def initialize(values : ExpectedActual(Array(ExpectedType), Array(ActualType)))
        super(true, values)
      end

      # Describes the condition that won't satsify the matcher.
      # This is informational and displayed to the end-user.
      def negated_message
        "#{@values.actual_label} does not contain #{@values.expected_label} (unordered)"
      end
    end

    # Match data specific to this matcher.
    # This type is used when the actual contents differs from the expected contents.
    private struct ContentMatchData(ExpectedType, ActualType) < CommonMatchData(ExpectedType, ActualType)
      # Creates the match data.
      def initialize(values : ExpectedActual(Array(ExpectedType), Array(ActualType)), @missing : Array(ExpectedType), @extra : Array(ActualType))
        super(false, values)
      end

      # Information about the match.
      def named_tuple
        super.merge({
          missing: @missing,
          extra:   @extra,
        })
      end

      # Describes the condition that won't satsify the matcher.
      # This is informational and displayed to the end-user.
      def negated_message
        "#{@values.actual_label} does not contain #{@values.expected_label} (content differs)"
      end
    end
  end
end
